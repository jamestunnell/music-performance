#!/usr/bin/env ruby

exe_name = File.basename(__FILE__)

doc = <<DOCOPT
Loads a music-transcription score from YAML file, and converts to MIDI file.

Usage:
  #{exe_name} <input>
  #{exe_name} <input> <output>
  #{exe_name} -h | --help
  #{exe_name} --version

Options:
  -h --help     Show this screen.
  --version     Show version.

DOCOPT

require 'docopt'
begin
  require "pp"
  args = Docopt::docopt(doc)
  pp args
rescue Docopt::Exit => e
  puts e.message
  exit
end

require 'yaml'
require 'music-transcription'
require 'midilib'
include MIDI
include Music

module Music
module Transcription
  class Score
    def start_notes_per_sec
      (@start_tempo * @start_meter.beat_duration) / 60.0
    end
    
    def start_usec_per_qnote
      spn = 1.0 / self.start_notes_per_sec
      spqn = spn / 4.0
      return (spqn * 1_000_000).to_i
    end
  end

  class Note
    QUARTER = Rational(1,4)
    
    p0 = Pitch.new(octave:-1,semitone:0)
    note_nums = { p0 => 0 }
    (1..127).each do |notenum|
      p = p0 + Pitch.new(semitone:notenum)
      note_nums[p] = notenum
    end
    MIDI_NOTENUMS = note_nums
    
    # compute number of pulses for note
    def midi_delta ppqn
      pulses = (self.duration / QUARTER) * ppqn
      return pulses.round
    end

    def midi_notenums
      pitches.map do |p|
        MIDI_NOTENUMS[p]
      end
    end
  end
end
end

def make_midi_seq(score)
  seq = Sequence.new()
  
  # first track for the sequence holds time sig and tempo events
  track0 = Track.new(seq)
  seq.tracks << track0
  track0.events << Tempo.new(score.start_usec_per_qnote)
  track0.events << MetaEvent.new(META_SEQ_NAME, 'Sequence Name')
  
  channel = 0
  score.parts.each do |part_name,part|
    # Track to hold part notes
    track = Track.new(seq)
    seq.tracks << track
    
    # Name the track and instrument
    track.name = part_name
    track.instrument = GM_PATCH_NAMES[0]
    
    # Add a volume controller event (optional).
    track.events << Controller.new(channel, CC_VOLUME, 127)
    
    # Change to particular instrument sound
    track.events << ProgramChange.new(channel, 1, 0)
    
    part.notes.each do |note|
      # number of pulses for note
      delta = note.midi_delta(seq.ppqn)
      
      notenums = note.midi_notenums
      case notenums.size
      when 0 # note is a rest
        notenum = 0
        velocity = 0
        track.events << NoteOn.new(channel, notenum, velocity, 0)
        track.events << NoteOff.new(channel, notenum, velocity, delta)
      when 1 # single pitch
        track.events << NoteOn.new(channel, notenums[0], 127, 0)
        track.events << NoteOff.new(channel, notenums[0], 127, delta)
      else   # chord
        notenums.each do |notenum|
          track.events << NoteOn.new(channel, notenum, 127, 0)
        end
        
        track.events << NoteOff.new(channel, notenums[0], 127, delta)
        notenums[1..-1].each do |notenum|
          track.events << NoteOff.new(channel, notenum, 127, 0)
        end
      end
    end
    
    channel += 1
  end
  
  return seq
end

fin_name = args["<input>"]
File.open(fin_name) do |fin|
  print "Reading file '#{fin_name}'..."
  score = YAML.load(fin.read)
  puts "complete"

  print "Making MIDI sequence..."
  seq = make_midi_seq(score)
  puts "complete"  

  fout_name = args["<output>"]
  if fout_name.nil?
    fout_name = "#{File.dirname(fin_name)}/#{File.basename(fin_name,File.extname(fin_name))}.mid"
  end
  print "Writing file '#{fout_name}'..."
  File.open(fout_name, 'wb'){ |fout| seq.write(fout) }
  puts "complete"
end
